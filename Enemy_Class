class Enemy:
    def __init__(self, cell, direction ):
        self.cell = cell
        self.direction = direction # going down 
    # MOVEMENT is on onStep()



"""

###########################


def drawGreenOgre(app): # GREEN OGRE
    row, col = app.greenOgre.cell
    drawWorldImgs(app, row, col, app.greenOgreImg)

def drawBlueOgre(app): ########//////////////
    row, col = app.blueOgre.cell
    drawWorldImgs(app, row, col, app.blueOgreImg)
    



## GREEN OGRE ######################################################### ////////////////////////////////////////////////////////
def takeStepEnemy(app):
    isLegal, var2 = takeStepEnemy_Helper(app, app.greenOgre.direction , app.greenOgre.cell)
    if isLegal:
        app.greenOgre.cell = var2
    else:
        app.greenOgre.direction = var2

# ENEMY TAKES STEPS / MOVES CELLS - think this is fine, works same as game 
def takeStepEnemy_Helper(app, direction, location):
    #                    [ DOWN,   RIGHT, UP,  LEFT]  
    possibleDirections = [(1, 0),  (0, 1), (-1, 0),  (0, -1)]
    index =  possibleDirections.index( app.greenOgre.direction ) 
    rowEnemy, colEnemy = location
    drow, dcol = direction 
    newPlrRow, newPlrCol = rowEnemy + drow, colEnemy + dcol
    if isLegalStep(app, newPlrRow, newPlrCol): 
        #actually move
        return True, (newPlrRow, newPlrCol)
    else:
        # ogre crashed into a wall- change directions, quick !
        index += 1 
        return False, possibleDirections[ index % 4]


## RECURSION 
## BLUE OGRE ######################################################### ////////////////////////////////////////////////////////
def findPathForBlueOgre(app, currPos, goalPos, possibleDirections, listOfMoves, count):

    if currPos == goalPos: #or count > 20: 
        return listOfMoves
    else:
        ogreRow, ogreCol = currPos #app.blueOgre.cell
        
        for rowDir, yDir in possibleDirections: 
            newRow, newCol  = (ogreRow + rowDir) , (ogreCol + yDir)
            nextMove = (newRow, newCol)


            # pop from directions 
            # currDirX, currDirY = app.blueOgre.direction
            # popThisDir = (currDirX * -1), (currDirY * -1)
            # copyDirs = [] + possibleDirections#.copy.copy

            # if popThisDir in possibleDirections:
            #     print('was in list, popped')
                
            #     index = possibleDirections.index(popThisDir)
            #     copyDirs.pop(index)

                        count += 1 # to stop recur 
            if (nextMove  in listOfMoves):
                print('uhmmm') 
                continue
            if isLegalStep(app, newRow  ,newCol) :
                listOfMoves = listOfMoves + [nextMove]
                print(listOfMoves)
                # make set to chekc 
                solution = listOfMoves + findPathForBlueOgre(app, nextMove, goalPos, possibleDirections, listOfMoves, count)
                # print( solution )
                if solution != None:
                    return solution
            else:
                print(f'\tnot a legal step for { (rowDir, yDir)} ; you get to location {nextMove}')
            # just for my sake
                # print('should be moving on??') 
                # continue 
            #else
            # nextMove = ogreRow + rowDir
            # try next direction ? 
        return None
    
def takeStep_BlueOgre(app):
    print('CALLING RECUR')
    # bestPossiblePath = findQuickestRoute(app.blueOgre.cell, app.playerOne.cell, app )
    # print(bestPossiblePath)
    possibleDirections = [(1, 0),  (0, 1), (-1, 0),  (0, -1)]
    # findPathForBlueOgre(app, app.blueOgre.cell, app.playerOne.cell, possibleDirections,[] ,1 ) # RECURSION -- COMMENTED OUT FOR NOW SO GAME DOES NOT CRASH 
    

"""
